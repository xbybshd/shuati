二分查找有很多写法，我们这里采用李煜东的书上推荐的基本写法  
### 基本的二分写法
```cpp
int vec[20] = {0};
int bigger(int l,int r,int val){//递增序列找x>=val最小数的下标
    while(l<r){
        int mid = (l + r) >> 1;
        if(vec[mid]>=val)
            r = mid;
        else
            l = mid + 1;
    }
    return l;
}

int smaller(int l,int r,int val){//递增序列找x<=val最小数的下标
    while(l<r){
        int mid = (l + r + 1) >> 1;
        if(vec[mid]<=val)
            l = mid;
        
        else
            r = mid - 1;
    }
    return l;
}
```  
#### 此种写法的几个关键点  
1.左右都是闭区间，l和r都是可以取到的值，这个与stl的左闭右开风格不一样。  
2.while里面执行的条件是l<r, 并不是等于.  
3.对于mid值的两种求法的区别：  
第一个例子： 我们要求的是第一个大于等于给定值val的数的下标，那么当判断条件成立，即vec[mid]>=val的时候，如果真实情况是vec[mid]大于val，那么真正的解必然在vec[mid]的左边，所以要取左半边，如果真实情况是等于的话，那么解也有可能包含mid，所以对于此种情况的解集，是包含mid的左区间，即r=mid。  
反之，解集就是不包含mid的右区间，所以l=mid+1。  

第二个例子：如果按照第一个例子的写法，求mid时不加1，我们求的是递增序列中最后一个小于等于val的数的下标，那么当判断条件满足时，如果vec[mid]<val，那么解集必然在mid右边，因为有可能有大于vec[mid]而小于val的数存在，如果是vec[mid]==val，因为我们的是最大的小于等于val，所以此时解集为mid。所以满足条件时，解集为包含mid的右半边，即l=mid，反之解集在不包含mid的左半边，即r=mid-1.  
但是这样会遇到一种情况，当r=l+1时，如果按照(l+r)>>1这种算法，那么mid=l;当真正的解是l时，l=mid=l，会陷入无法缩小区间的循环，当解在r时，返回的是l的值，所以此种情况求mid时要加1.

#### 总结：对于求中位数时用哪种方法的判断，  
先得出满足判断条件和不满足判断条件时，解集的情况  
比如第一种就是$[l,mid],(mid,r]$ mid属于左边，这样就不需要加1
第二种$[l,mid),[mid,r]$ 此种情况就要加1.

## 拓展的二分写法

对于mid=(l+r)>>1时，mid是不会取到r这个值的，因为有解区间是在$[l,mid]$。所以我们可以将二分区键$[1,n]$扩展为$[1,n+1]$,此时无解的情况会落在n+1上,这个就类似stl的左闭右开风格。类似的，mid=(l+r+1)>>1时，mid是取不到l的，此时可以拓展区间为$[0,n]$,无解情况落在0上。  
例1：递增序列找最小的大于等于val的数，即val的后继
```cpp
int vec[5]={1,2,3,4,5};
```
如果你找的数小于最左边的数，比如0<1,那么它解是不会出现在更左边的，因为第一个数已经大于等于val了，所以不可能无解。如果你找的是大于等于最右边的数，比如6，那么序列内会无解，所以只能在最后一个数之后的位置，也就是n+1。 
例2：递减序列找最小的大于等于val的数，即val的前驱
```cpp
int vec[5]={5,4,3,2,1};
```
如果我们找6，那么就会无解，真正的位置在左边，如果找0，那么有解为最后的1，所以对这种情况写二分应该用第二种方法
```cpp
//递减序列找前驱，最小的大于等于val的数
int find_down_front(int *vec,int l,int r,int val){
    while(l<r){
        int mid=(l+r+1)>>1;
        if(vec[mid]>=val){
            l=mid;
        }
        else{
            r=mid-1;
        }
    }
    return l;
}
```
这种拓展的写法当我们需要不断往序列里添加新的无解元素时，非常方便

### 总结：
对于二分的写法判断，先判断对于无解的情况出现在左边还是右边，如果是右边就mid=(l+r)>>1求mid，如果是左边就mid=(l+r+1)>>1; 确定mid求法之后，再确定满足条件的解集和不满足条件的解集的左右情况，最后在确定vec[mid]时，mid应该归于左边还是右边.

