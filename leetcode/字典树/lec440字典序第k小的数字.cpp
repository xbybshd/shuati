class Solution {
public:
    // 题目的意思是给定一个范围1-n，在这么多数里面。如果按照字典序排序，那么第k个数是多少。这n个数本质上是可以安排在一颗十叉树上
    // 从第一层看，每个子树1-9都会存在，但是都包含了n的一部分数据，所以如果我们想确定k在子树的位置，就需要得出，以某个数为根，它的
    // 子树里面在n里一共有多少个数，这里输出x就是树的根，它不只是个位数，任意一个数比如24也可以作为根
    // 在每个子树里面，分为上下限的节点，就是最左右的节点，它们代表这一层的数据范围，比如2的子树，第一层是[2,3),第二层是[20,30),
    // 第三层是[200,300) 以此类推，计算的方式就是如果n比右边大，用右边减去左边，因为这说明n在下面的层，如果n小于右边，那就用n减去右边
    // 每次增加层数将左右都乘上10即可，最后结束是左边大于n也就是n所在层的下一层九不会遍历了
    int getChildCount(long long x, long long n) {
        long long cur = x, next = x + 1, con = 0;
        while (cur <= n) {
            con += std::min(n + 1, next) - cur;
            cur *= 10;
            next *= 10;
        }
        return con;
    }

    // 这里p最开始是从1开始的每个个位数，然后开始计算n在p的所有子树的节点数量，如果数量比k小，那说明k不在这个子树内，需要检查平行的
    // 下一棵子树，此时k需要减去这个子树的数量，在p++，说明是平移到右边一颗
    // 如果子节点数量大于k，那么说明k在这颗子树内部，那就需要进入下一层，p为根的时候，下一层的第一个子树根节点就是p乘上10，搜索也是
    // 从第一个根节点开始搜索，k--是因为上一层的根节点p也算一个节点
    int findKthNumber(int n, int k) {
        long long p = 1;
        while (k > 1) {
            int child_count = getChildCount(p, n);
            if (child_count < k) {
                k -= child_count;
                p++;
            }
            else {
                k--;
                p *= 10;
            }
        }
        return p;
    }
};