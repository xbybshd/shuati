class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0, fast = 0;
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);
        fast = 0;
        while (fast != slow) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return fast;
    }
};

// 结论，把数组看成静态链表，每个位置的数值就是指向的下一个节点，那么这个链表或者图必然有环，其环的入口必然是重复数
// 证明：
// 数的范围是1-n, 位置数量是n+1，有两个数是x
// 对于0来说，只有下标，没有数值，所以0节点只有出度为1，对于除了x的其余下表节点来说，它们的出度必然只有1，入度因为只有x是重复
// 所以入度也是1，在这种情况下，我们从0开始遍历，必然可以无限遍历下去，所以必然有环，理论上来说不需要遍历完就看见有有环。
// 下面证明环包含x，且入口也是x:
// 首先，遍历是从0开始的，它的入度为0，那么就不可能再开始就进入环，必然是移动再非环节点上，再从入口进入环，这里入口要求入度为2
// 一个是环的一边，另一个是非环节点的进入。满足入度为2的只有x节点。所以可以用链表找环入口的方式求。