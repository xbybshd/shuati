# TCP
### 保证可靠性：  
1.确认机制，定时器确认重传  
2.校验和  
3.重新排序  
4.流量控制，拥塞控制

### 字段意义： 
1.序号：当前报文首字段在总报文的序号  
2.确认号：上一次接收的保温段最后字节序号+1

### 三次握手  
1.客户端发送SYN:随意序号xxx-xxx，不带数据  
2.服务端发送SYN:另一个随意序号 yyy-yyy，不带数据 ACK：xxx+1  
3.客户端确认ACK：yyy+1；


### 四次挥手  
因为全双工，两边都可以发数据，必须等一边发完数据之后才可以再发FIN   
收到FIN只代表不会有数据传来，仍然可以发数据  

1.客户端发送一个FIN：随意序号 xxx-xxx，
2.服务端发送一个确认ack：xxx+1
3.服务端还可以继续发送数据，客户端继续发送确认ACK
4.当服务端数据发完之后，发送FIN：随意序号yyy-yyy
5.客户端确认ACK：yyy+1

除了SYN之外，后序序号都是相对值

### 连接时超时  
客户端会以不断增长的时间间隔不断发送SYN  

### 挥手状态和time_wait  
客户端发FIN--->FIN_WAIT1--->客户端收到服务端确认的ACK--->FIN_WAIT2---->(服务端发数据)--->收到服务端FIN，发确认的ACK---->TIME_WAIT   

客户端发出确认服务端的FIN的ACK之后要等待2MSL(最大报文生存时间)因为：  
1.客户端要等待服务端收到了这个ack，如果服务端没有收到，必然会在2MSL内必然会有新的FIN到达，此时可以继续发ACK，如果此时断开了，服务端相当于在重复发送FIN，浪费资源  
2.因为两边都不打算继续发数据了，这个时候如果网络上有残留的数据，客户端先关闭再打开，有可能会受到上一次链接的残余数据，等待2msl之后就不会有任何旧报文残留

### 确认机制  
tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以tcp是可靠的

而udp发送数据，对端是不会返回确认信息的，因此不可靠

### 滑动窗口
确认ACK后面会跟win：xxx来通告发送端接收端还可以接受大小为多少的数据

发送端的滑动窗口：     
！！！！！|   接收端ACK通告的win     |  
^^^^^^^|************ |*************|$$$$$$$$$  
发送已确认   发送未被确认    可以发送     不能发送直到窗口移动   

 
PUSH 标志  
直接向服务器提交数据 


### 拥塞窗口
流量控制：  
1.接收方控制：ack确认窗口  
2.发送方控制：发送方控制拥塞窗口  
慢启动：初始化为1，收到几个ack窗口加几  
发送方的发送上限取确认窗口和拥塞窗口最小值

### 拥塞避免算法  
发生拥塞标志  
1.超时没有收到确认ACK  
2.收到3个ack

拥塞窗口cwnd   慢启动门限ssthresh

小于慢启动门限的时候，收到几个ack拥塞窗口就加几； 
大于慢启动门限的时候，线性增加，加1最大报文段，具体算法可能不一样

发生超时：ssthresh减半，cwnd为1


快重传： 
服务端收到失序的报文段，应该立即返回ack，其ack确认的是最后的有序报文，丢失的包后面的包发过来，确认的是想要丢失的包
发送端收到三个重复ack应该实行快重传，因为此时两端仍然有数据流动，说明不是那么拥塞，不想减少数据流

ssthresh等于当前cwnd的一半 cwnd=ssthres
然后将cwnd拥塞窗口设为ssthresh+3MSL