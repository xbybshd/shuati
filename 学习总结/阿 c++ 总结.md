### const细节  
局部变量的const在编译的时候会直接将所有要用此变量赋值的语句直接用const变量的常数值替换  
就算之前取地址去const，然后用新地址改变这个const变量，之后的赋值代码语句都是之前填好的，依然是原来的const  

全局变量的const直接放在只读data段里面


### lambda表达式  
```cpp
[函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -> 返回值类型 {函数体}

[]        //未定义变量.试图在Lambda内使用任何外部变量都是错误的.
[x, &y]   //x 按值捕获, y 按引用捕获.
[&]       //用到的任何外部变量都隐式按引用捕获
[=]       //用到的任何外部变量都隐式按值捕获
[&, x]    //x显式地按值捕获. 其它变量按引用捕获
[=, &z]   //z按引用捕获. 其它变量按值捕获
```

　不同编译器的具体实现可以有所不同,但期望的结果是:按引用捕获的任何变量,lambda函数实际存储的应该是这些变量在创建这个lambda函数的函数的栈指针,而不是lambda函数本身栈变量的引用. 不管怎样, 因为大数lambda函数都很小且在局部作用中, 与候选的内联函数很类似, 所以按引用捕获的那些变量不需要额外的存储空间.


### list的排序  
对于无法顺序访问的容器，sort用的是list自己的排序l.sort,forward也是  
forward list用的是push_front   

### 关联性容器的find  
set，map，multiset,multimap 出了泛用性的find外，自已有一个find，是基于二叉树查找，很快  

map插入  map.insert(pair<int,int>(1,2));  此种方式如果key重复就插不进去   
map\[1]=2  此种方式如果1重复会将2覆盖掉  
mutlimap不可以用下标插入的方式   

### static类成员函数

由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数

不能访问非static的类成员，只能访问 static修饰的类成员。

### 多态  
多态是同一个行为具有多个不同表现形式或形态的能力。

多态性意味着有多重形式。在面向对象编程范式中，多态性往往表现为"一个接口，多个功能"。


### const 迭代器  
迭代器的顶层和底层const与const指针的相反  

### 类的成员函数的const版本  
const类的对象会首先调用const版本的类函数，正常的会调用正常的  

### 类的const成员函数需要改变类成员的情况   
就将需要改变的类成员声明成mutable  

### no const函数可以复用const函数  
但是需要类型转换，const_cast<>会去掉const，static_cast会加上const

### 初始化与默认构造函数  
如果默认构造函数不是初值列表的形式，而是内部赋值的形式，在调用赋值之前，会进行初始化，所以还不如直接将默认构造函数写成初始化列表   

### 全局static和局部static   
局部static初始化在作用域声明开始，但是在作用于结束之后不会被销毁，但不可用，如果以引用形式返回给其他变量，那么依然可用，可用用来避免
不同文件全局static初始化的顺序问题  

### 拷贝构造运算符声明为private 
基类声明为private 派生类拒绝声明拷贝构造运算符，如果不想要拷贝构造函数和运算符，可以直接把他们声明为private  
如果想防止成员函数和友元函数调用，可以声明基类，这个基类将两个函数声明为private   

### 虚析构函数的必要性  
如果一个类是要被继承的，虚构函数应该被声明为虚析构，因为存在基类指针指向派生类对象，此时如果通过这个基类指针delete，如果析构函数不是虚的
会只调用基类析构函数而不析构派生类。按照经验，如果一个类有析构函数，那么这个类大概率是用来继承的，所以要有析构函数  

### 析构函数不要throw异常，要么abort，要么吞  

### 构造函数和析构函数里面不能出现虚函数   
构造函数调用虚函数，如果要构造派生类，必然先构造基类构造函数，此时虚表是基类的，调用的是基类构造函数的虚函数   
析构函数调用虚函数，在析构派生类的时候，先析构派生类，此时虚表的替换时机是不知道的，调用虚函数是基类和派生类的也是不知道的    
如果想实现多态，可以把不同函数的版本统一放在基类非虚函数中，然后在初值列表中选择参数  

### 赋值函数的自我赋值  
如果类中有堆上元素，在自我赋值之前原本的堆元素要释放，如果自我赋值之前不检查，那么会发生自己释放自己的错误，所以如果是自我赋值那就直接返回*this  

### 派生类拷贝构造函数应该用初值列表先调用基类拷贝构造函数  
在初值列中初始化一般被认为不会生成新对象，而且const对象只能初始化，如果在派生类函数体调用基类拷贝构造函数相当于生成了一个新对象和对const的赋值。

### 智能指针和原始指针的区别在于  
当作用于结束之后，new 出来的指针需要手动释放，而智能指针是将指针放进一个类，而这个类有析构函数来free，当这个类离开作用域的时候，会因为它是一个类
而自动调用析构函数，自动free。


### 移动构造函数的优化点  
函数传形参的时候，如果不是传引用，直接传形参类型，如果传入的实参是一个临时变量，函数结束就不需要那种，那么在传参的时候再拷贝一次就没有必要
因为拷贝的在函数结束会销毁，之前的实参也要销毁，那么可以将临时的实参直接当做形参，不需要拷贝一次，移动构造就是这样，在传参的时候，加std::move
，在应该拷贝的时候就调用移动构造。   

完美转发解决的问题是，接受右值的函数，其参数是右值引用，注意：是没有右值形式的参数的。 这个函数内部还要用其他函数，而其他函数也要用这个右值作为参数，此时这个右值已经是右值引用，是一个左值了，所以要将其再类型转换为右值。这个类型转换是有条件的。


### auto推导  
会去除传入变量的引用性来得到原始类型T