### const细节  
局部变量的const在编译的时候会直接将所有要用此变量赋值的语句直接用const变量的常数值替换  
就算之前取地址去const，然后用新地址改变这个const变量，之后的赋值代码语句都是之前填好的，依然是原来的const  

全局变量的const直接放在只读data段里面


### lambda表达式  
```cpp
[函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -> 返回值类型 {函数体}

[]        //未定义变量.试图在Lambda内使用任何外部变量都是错误的.
[x, &y]   //x 按值捕获, y 按引用捕获.
[&]       //用到的任何外部变量都隐式按引用捕获
[=]       //用到的任何外部变量都隐式按值捕获
[&, x]    //x显式地按值捕获. 其它变量按引用捕获
[=, &z]   //z按引用捕获. 其它变量按值捕获
```

　不同编译器的具体实现可以有所不同,但期望的结果是:按引用捕获的任何变量,lambda函数实际存储的应该是这些变量在创建这个lambda函数的函数的栈指针,而不是lambda函数本身栈变量的引用. 不管怎样, 因为大数lambda函数都很小且在局部作用中, 与候选的内联函数很类似, 所以按引用捕获的那些变量不需要额外的存储空间.


### list的排序  
对于无法顺序访问的容器，sort用的是list自己的排序l.sort,forward也是  
forward list用的是push_front   

### 关联性容器的find  
set，map，multiset,multimap 出了泛用性的find外，自已有一个find，是基于二叉树查找，很快  

map插入  map.insert(pair<int,int>(1,2));  此种方式如果key重复就插不进去   
map\[1]=2  此种方式如果1重复会将2覆盖掉  
mutlimap不可以用下标插入的方式   

### static类成员函数

由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数

不能访问非static的类成员，只能访问 static修饰的类成员。

### 多态  
多态是同一个行为具有多个不同表现形式或形态的能力。

多态性意味着有多重形式。在面向对象编程范式中，多态性往往表现为"一个接口，多个功能"。


### const 迭代器  
迭代器的顶层和底层const与const指针的相反  

### 类的成员函数的const版本  
const类的对象会首先调用const版本的类函数，正常的会调用正常的  

### 类的const成员函数需要改变类成员的情况   
就将需要改变的类成员声明成mutable  

### no const函数可以复用const函数  
但是需要类型转换，const_cast<>会去掉const，static_cast会加上const

### 初始化与默认构造函数  
如果默认构造函数不是初值列表的形式，而是内部赋值的形式，在调用赋值之前，会进行初始化，所以还不如直接将默认构造函数写成初始化列表   

### 全局static和局部static   
局部static初始化在作用域声明开始，但是在作用于结束之后不会被销毁，但不可用，如果以引用形式返回给其他变量，那么依然可用，可用用来避免
不同文件全局static初始化的顺序问题  

### 拷贝构造运算符声明为private 
基类声明为private 派生类拒绝声明拷贝构造运算符，如果不想要拷贝构造函数和运算符，可以直接把他们声明为private  
如果想防止成员函数和友元函数调用，可以声明基类，这个基类将两个函数声明为private   

### 虚析构函数的必要性  
如果一个类是要被继承的，虚构函数应该被声明为虚析构，因为存在基类指针指向派生类对象，此时如果通过这个基类指针delete，如果析构函数不是虚的
会只调用基类析构函数而不析构派生类。按照经验，如果一个类有析构函数，那么这个类大概率是用来继承的，所以要有析构函数  

### 析构函数不要throw异常，要么abort，要么吞  

### 构造函数和析构函数里面不能出现虚函数   
构造函数调用虚函数，如果要构造派生类，必然先构造基类构造函数，此时虚表是基类的，调用的是基类构造函数的虚函数   
析构函数调用虚函数，在析构派生类的时候，先析构派生类，此时虚表的替换时机是不知道的，调用虚函数是基类和派生类的也是不知道的    
如果想实现多态，可以把不同函数的版本统一放在基类非虚函数中，然后在初值列表中选择参数  

### 赋值函数的自我赋值  
如果类中有堆上元素，在自我赋值之前原本的堆元素要释放，如果自我赋值之前不检查，那么会发生自己释放自己的错误，所以如果是自我赋值那就直接返回*this  

### 派生类拷贝构造函数应该用初值列表先调用基类拷贝构造函数  
在初值列中初始化一般被认为不会生成新对象，而且const对象只能初始化，如果在派生类函数体调用基类拷贝构造函数相当于生成了一个新对象和对const的赋值。

### 智能指针和原始指针的区别在于  
当作用于结束之后，new 出来的指针需要手动释放，而智能指针是将指针放进一个类，而这个类有析构函数来free，当这个类离开作用域的时候，会因为它是一个类
而自动调用析构函数，自动free。


### 移动构造函数的优化点  
函数传形参的时候，如果不是传引用，直接传形参类型，如果传入的实参是一个临时变量，函数结束就不需要那种，那么在传参的时候再拷贝一次就没有必要
因为拷贝的在函数结束会销毁，之前的实参也要销毁，那么可以将临时的实参直接当做形参，不需要拷贝一次，移动构造就是这样，在传参的时候，加std::move
，在应该拷贝的时候就调用移动构造。   

完美转发解决的问题是，接受右值的函数，其参数是右值引用，注意：是没有右值形式的参数的。 这个函数内部还要用其他函数，而其他函数也要用这个右值作为参数，此时这个右值已经是右值引用，是一个左值了，所以要将其再类型转换为右值。这个类型转换是有条件的。


### auto推导  
会去除传入变量的引用性来得到原始类型T

### 箭头运算符  
箭头操作符(->)的通常用法是，使用一个类对象的指针来调用该指针所指对象的成员。左操作数为对象指针(this)，右操作数为该对象的成员名称。定义重载箭头操作符之后看起来就有点特别，可以用类对象的指针来调用，也可以用类对象直接调用。重载箭头操作符必须定义为类成员函数。

箭头操作符与众不同。它可能表现得像二元操作符一样：接受一个对象和一个成员名。对对象解引用以获取成员。不管外表如何，箭头操作符不接受显式形参。这里没有第二个形参，因为 -> 的右操作数不是表达式，相反，是对应着类成员的一个标识符。没有明显可行的途径将一个标识符作为形参传递给函数，相反，由编译器处理获取成员的工作。

箭头操作符的调用过程
当这样编写时：

     point->action();

由于优先级规则，它实际等价于编写：

     (point->action)();

    换句话说，我们想要调用的是对 point->action 求值的结果。编译器这样对该代码进行求值：

（1）.如果 point 是一个指针，指向具有名为 action 的成员的类对象，则编译器将代码编译为调用该对象的 action 成员（默认语义）。

（2）.否则，如果 point(注：中文版primer误写为action) 是定义了 operator-> 操作符的类的一个对象，则 point->action 与 point.operator->()->action 相同。即，执行 point 的 operator->()，然后使用该结果重复这三步。（递归调用）

（3）.否则，代码出错。

总结：通过箭头（->）操作符的执行过程，我们可以得到结论“重载箭头操作符必须返回指向类类型的指针，或者返回定义了自己的箭头操作符的类类型对象。”返回前者用于执行编译器默认语义终结箭头运算符的调用（如果返回类型是指针，则内置箭头操作符可用于该指针，编译器对该指针解引用并从结果对象获取指定成员），返回后者用于递归调用。（如果返回类型是类类型的其他对象（或是这种对象的引用），则将递归应用该操作符。编译器检查返回对象所属类型是否具有成员箭头，如果有，就应用那个操作符；否则，编译器产生一个错误。这个过程继续下去，直到返回一个指向带有指定成员的的对象的指针，或者返回某些其他值，在后一种情况下，代码出错。）



# static dynamic  
static 可以隐式类型转换，转换void指针，不能转其他类型指针，可以无限制转换基类子类，不需要多态
dynamic 转换基类子类必须要多态


## &&引用  
对右值引用使用std::move，对通用引用使用std::forward
右值引用：Weight&& ，类型确定，
通用引用：typename &&，可能会被推导成左值